Architecture
############

Contemporary operating systems are immensely complex to accommodate a
large variety of applications on an ever diversifying spectrum of hardware
platforms. Among the functionalities provided by a commodity operating system
are device drivers, protocol stacks such as file systems and network
protocols, the management of hardware resources, as well as the provisioning
of security functions. The latter category is meant for protecting the
confidentiality and integrity of information and the lifelines of critical
functionality. For assessing the effectiveness of such a security function,
two questions must be considered. First, what is the potential attack surface
on the function? The answer to this question yields an assessment about the
likelihood of a breach. Naturally, if there is a large number of potential
attack vectors, the security function is at high risk. The second question is:
What is the reach of a defect? If the compromised function has unlimited
access to all information processed on the system, the privacy of all users
may be affected. If the function is able to permanently install software, the
system may become prone to back doors.

Today's widely deployed operating systems do not isolate security-critical
functions from the rest of the operating system. In contrary, they are
co-located with most other operating-system functionality in a single
high-complexity kernel. Thereby, those functions are exposed to the other
parts of the operating system. The likelihood for of a security breach is as
high as the likelihood for bugs in the overly complex kernel. In other words,
it is certain. Moreover, once an in-kernel function has been compromised, the
defect has an unlimited reach on the system.

The Genode architecture was designed to give more assuring answers to the two
stated questions. Each piece of functionality should be exposed to only those
parts of the system, on which it ultimately depends. But it remains hidden
from all unrelated parts. This minimizes the attack surface on individual
security functions and thereby reduces the likelihood for a security breach.
In the event that one part of the system gets compromised, the reach of the
defect is limited to the particular part and its dependent parts. But
unrelated functionalities remain unaffected. To realize this idea, Genode
composes the system out of many components that interact with each other. Each
component serves a specific role and uses well-defined interfaces to interact
with its peers. For example, a network driver accesses a physical network card
and provides a bidirectional stream of network packets to another component,
which, in turn, may process the packets using a TCP/IP stack and a network
application. Even though the network driver and the TCP/IP stack cooperate
when processing network packets, they are living in separate protection
domains. So a bug in one component cannot observe or corrupt the internal
state of another.

Such a component-based architecture, however, raises a number of questions,
which are addressed throughout this chapter.
Section [Capability-based security] explains how components can cooperate
without inherently trusting each other.
Section [Recursive system structure] answers the questions of who defines the
relationship between components and how components become acquainted with each
other.
An operating system ultimately acts on physical hardware resources such
as memory, CPUs, and peripheral devices.
Section [Core - the root of the component tree] describes how such resources
are made available to components.
Section [Component creation] answers the question of how a new component comes
to life.
The variety of relationships between components and their respective
interfaces call for different communication primitives. Section
[Inter-component communication] introduces inter-component communication
mechanisms in detail.


Capability-based security
=========================

| TODO intro, possibly provide general background information (independent
| from Genode)

This section introduces the nomenclature and the general model of Genode's
capability-based security concept. The Genode OS framework is not tied to one
kernel but supports a variety of kernels as base platforms. On each of those
base platforms, Genode uses different kernel mechanisms to implement the
general model as closely as possible. Note however that not all kernels
satisfy the requirements that are needed to implement the model securely. For
assessing the security of a Genode-based system, the respective
platform-specific implementation must be considered. Section
[Capability-based security in depth] provides details for selected kernels.


Capability spaces, object identities, and RPC objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Each component lives inside a protection domain that provides an isolated
execution environment.

[tikz img/protection_domain]

Genode provides an object-oriented way of letting components interact with
each other. Analogously to object-oriented programming languages, which have
the notion of objects and pointers to objects, Genode introduces the notion of
RPC objects and capabilities to RPC objects.

An _RPC object_ provides a remote-procedure call (RPC) interface. Similar to a
regular object, an RPC object can be constructed and accessed from within the
same program. But in contrast to a regular object, it can also be called from
the outside of the component. What a pointer is to a regular object, a
_capability_ is to an RPC object. It is a token that unambiguously refers to
an RPC object. In the following, we represent an RPC object as follows.

[tikz img/rpc_object]

The circle represents the capability associated with the RPC object. Like a
pointer to an object, that can be used to call a function of the pointed-to
object, a capability can be used to call functions of its corresponding RPC
object. However, there are two important differences between a capability and
a pointer. First, in contrast to a pointer that can be created out of thin air
(e.g., by casting an arbitrary number to a pointer), a capability cannot be
created without an RPC object. At the creation time of an RPC object, Genode
creates a so-called _object identity_ that represents the RPC object in the
kernel. Figure [img/object_identity] illustrates the relationship of an
RPC object and its object identity.

[tikz img/object_identity]
  Relationship between an RPC object and its corresponding object identity.

For each protection domain, the kernel maintains a so-called capability space,
which is a name space that is local to the protection domain. At the creation time of
an RPC object, the kernel creates a corresponding object identity and lets a
slot in the protection domain's capability space refer to the RPC object's
identity. From the component's point of view, the RPC object A has the name 3.
When interacting with the kernel, the component can use this number to refer
to the RPC object A.


Delegation of authority and ownership
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[tikz img/delegation]
  The transitive delegation of a capability from one protection domain to
  others.

The second difference between a pointer and a capability is that a capability
can be passed to different components without losing its meaning. The transfer
of a capability from one protection domain to another delegates the authority
to use the capability to the receiving protection domain.
This operation is called _delegation_ and can be performed only by the kernel.
Note that originator of the delegation does not diminish its authority by
delegating a capability. It merely shares its authority with the receiving
protection domain.
Figure [img/delegation] shows the
delegation of the RPC object's capability to a second protection domain
and a further delegation of the capability from the second to a third
protection domain.
When the kernel delegates a capability from one to another protection domain,
it inserts a reference to the RPC object's identity a free slot in the
target's capability space. Within protection domain 2, the RPC object can
be referred to by the number 5. Within protection domain 3, the same RPC
object is known as 2.
Note that the capability delegation does not hand over the ownership of the
object identity to the target protection domain. The ownership is always
retained by the protection domain that created the RPC object.

Only the owner of an RPC object is able to destroy it along with the
corresponding object identity. Upon destruction of an object identity, the
kernel removes all references to the vanishing object identity from all
capability spaces. This effectively renders the RPC object inaccessible for
all protection domains. Once the object identity for an RPC object is gone,
the owner can destruct the actual RPC object.


Capability invocation
~~~~~~~~~~~~~~~~~~~~~

Capabilities enable components to call methods of RPC objects
provided by different protection domains. A component that uses
an RPC object plays the role of a _client_ whereas a component that
owns the RPC object acts in the role of a _server_. The interplay between
client and server is very similar to a situation where a program calls
a local function. The caller puts the function arguments to a place where
the callee will be able to pick them up and then passes control to the
callee. When the callee takes over control, it obtains the function
arguments, executes the function, puts the results to a place where the
caller can pick them up, finally hands the control back to the caller.
In contrast to a program-local function call, however, client and server
are different _threads_ in their respective protection domains. The thread
at the server side is called _entrypoint_ denoting the fact that it
becomes active only when a call from a client enters the protection domain.
In order to be able to act as a server, a component has to have at least
one entrypoint.

[tikz img/entrypoint]

The wiggly arrow denotes that the entrypoint is a thread. Besides being a
thread that waits for incoming requests, the entrypoint is responsible for
maintaining the association between RPC objects with their corresponding
capabilities. This association was illustrated by the link between the RPC
object and its capability in the previous figures. In order to become callable
from the outside, an RPC object must be associated with a concrete entrypoint.
This operation results in the creation of the object's identity and the
corresponding capability. During the lifetime of the object identity, the
entrypoint keeps the association between the RPC object and its capability in
a data structure called _object pool_, which allows for looking up the
matching RPC object for a given capability. Figure [img/object_pool] shows a
scenario where two RPC objects are associated with one entrypoint in the
protection domain of a server. The capability for the RPC object A has been
delegated to a client.

[tikz img/object_pool]
  The RPC object A and B are associated with the server's entrypoint.
  A client has a capability for A but not for B.
  For brevity, the kernel-protected object identities are
  not depicted. Instead, the dashed line between the capabilities shows that
  both capabilities refer to the same object identity.

If a protection domain is in possession of a capability, each thread executed
within this protection domain can issue a call to a member function of the RPC
object that is referred to by the capability. Because this is not a normal
function call but the invocation of an object located in a different
protection domain, this operation has to be provided by the kernel. Figure
[img/capability_call] illustrates the interaction of the client, the kernel,
and the server. The kernel operation takes the client-local name of the
invoked capability, the opcode of the called function, and the function
arguments as parameters. When entering the kernel, the client's thread is
blocked until it receives a response. The operation of the kernel is
represented by the dotted line.
The kernel takes the supplied local name as an
index into the client's capability space to look up the object identity, to
which the capability refers. Given the object identity, kernel is able to
determine the entrypoint that is associated with the object identity and wakes
up the entrypoint's thread with the information about the incoming request.
Among those information is the server-local name of the capability that was
invoked. Note that the kernel has translated the client-local name
into the corresponding server-local name. The capability name spaces of client and
server are entirely different. The entrypoint uses this number as a key into
its object pool to find the locally implemented RPC object A that belongs to
the invoked capability. It then performs a method call of the so-called
_dispatch_ function on the RPC object. The dispatch function maps the supplied
function opcode to the matching member function and calls this function
with the request arguments.

[tikz img/capability_call]
  Control flow between client and server when the client calls a method of an
  RPC object.

; We could illustrate the lookup of the RPC object from the object pool.

The member function may produce function results. Once the RPC object's member
function returns, the entrypoint thread passes the function results to the
kernel by performing the kernel's _reply_ operation. At this point, the
server's entrypoint becomes ready for the next request. The kernel, in turn,
passes the function results as return values of the original call operation to
the client and wakes up the client thread.


Capability delegation through capability invocation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Section [Delegation of authority and ownership] explained that capabilities
can be delegated from one protection domain to another via a kernel operation.
But it left open the question how this procedure works. The answer is the use
of capabilities as RPC message payload. Similar to how a caller of a regular
function can pass a pointer as an argument, a client can pass a capability as
an argument to an RPC call. In fact, passing capabilities as RPC arguments or
results is synonymous to delegating authority between components.
If the kernel encounters a capability as an argument of a call operation, it
performs the steps illustrated in Figure [img/capability_argument].
;
; We direct the following lines directly to LaTeX to parse the math
; environments.
;
: The local names are denoted as $cap$, e.g., $cap_{arg}$
: is the local name of the object identity at the client side, and
: $cap_{translated}$ is the local name of the same object identity at the
: server side.

[tikz img/capability_argument]
  Procedure of delegating a capability specified as RPC argument from a
  client to a server.

# The kernel looks up the object identity in the capability space of the
  client. This lookup may fail if the client specified a number of an empty
  slot of its capability space. Only if the lookup succeeds, the kernel is
  able obtain the object identity referred to by the argument. Note that under
  no circumstances, the client can refer to object identities, for which it
  has no authority because it can merely specify the object identities
  reachable through its capability space. For all non-empty slots of its
  capability space, the protection domain was authorized to use their
  referenced object identities by the means of prior delegations.

# Given the object identity of the argument, the kernel searches the server's
  capability space for a slot that refers to the object identity. Note that
  the term "search" does not necessarily refer to an expensive linear search.
  The efficiency of the operation largely depends on the kernel implementation.

# If the server already possesses a capability to the object identity, the
  kernel translates the argument to the corresponding local name when passing
  it as part of the request to the server. If the server does not yet possess
  a capability to the argument, the kernel installs a new entry into the
  server's capability space. The new entry refers to the object identity of
  the argument. At this point, the authority over the object identity has been
  delegated from the client to the server.

# The kernel passes the just-created local name of the argument as part of the
  request to the server. Even though the above description covered the
  delegation of a single capability specified as argument, it is possible to
  delegate more than one capability with a single RPC call.

Analogously to how capabilities can be delegated from a client to a server as
arguments of an RPC call, capabilities can be delegated in the other direction
as part of the reply of an RPC call. The procedure in the kernel is the same
in both cases.


\clearpage

Recursive system structure
==========================

The previous section introduced capability delegation as the fundamental
mechanism to pass authority over RPC objects between protection domains. But
in the given examples, the client was already in possession to a capability to
the server's RPC object. This raises the question of how do clients get
acquainted to servers?


Component ownership
~~~~~~~~~~~~~~~~~~~

In a Genode system, each component (except for the initial component called
core) has a parent, which owns the component. The _ownership_ relation between
a parent and a child is two-fold.

[tikz img/parent_child]

On the one hand, ownership stands for _responsibility_. The parent is
responsible to provide the physical resources (such as a memory budget) to
the child at the creation time but also during the child's entire lifetime.
Creating children is not for free but the parent has to pay for them. Besides
being the provider of resources, the parent defines all aspects of the
child's execution, and serves as the child's primary point of
contact for seeking acquaintances with other components.

[tikz img/parent_capability]
  Initial relationship between a parent and a new created child.

On the one hand, ownership stands for _responsibility_.
Each component requires physical resources such as the memory used by the
component or in-kernel data structures that represent the component in the
kernel.
The parent is responsible to provide a budget of those physical resources to
the child at the child's creation time but also during the child's entire
lifetime.
As the parent has to assign a fraction of its own physical resources to its
children, it is the parent's natural interest to maintain the balance of
the physical resources split between itself and each of its children.
Besides being the provider of resources, the parent defines all aspects of the
child's execution and serves as the child's primary point of contact for
seeking acquaintances with other components.

Each new component is created as an empty protection domain. It is up to the
parent to populate the protection domain with code and data, and to create a
thread that executes the code within the protection domain. At creation time,
the parent installs a single capability called _parent capability_ into the
new protection domain. The parent capability enables the child to perform RPC
calls to the parent. The child is unaware of anything else that exists in the
Genode system. It does not even know its own identity nor the identity of its
parent. All it can do is issuing calls to its parent using the parent
capability. Figure [img/parent_capability] depicts the situation right after
the creation of a child component. A thread in the parent component created a
new protection domain and a thread residing in the protection domain. It also
installed the parent capability referring to an RPC object provided by the
parent. To provide the RPC object, the parent has to maintain an entrypoint.
For brevity, entrypoints are not depicted in this and the following figures.
Section [Component creation] covers the procedure of creating a component in
detail.

The ownership relation between parent and child implies that each component
has to inherently trust its parent. From a child's perspective, its parent
is as powerful as the kernel. Whereas the child has to trust its parent,
a parent does not necessarily need to trust its children.


Recursive system structure
~~~~~~~~~~~~~~~~~~~~~~~~~~

The parent-child relationship is not limited to a single level. Child
components are free to use their resources to create further children, thereby
forming a tree of components. Figure [img/recursive_structure] shows an
example scenario. The init component creates sub systems according
to its configuration. In the example, it created two children, namely
a GUI and a launcher. The latter allows the user to interactively create
further subsystems. In the example, launcher was used to start an application.

[tikz img/recursive_structure]
  Example of a tree of components. The red arrow represents the ownership
  relation.

At each position in the tree, the parent-child interface is the same. The
position of a component within the tree is just a matter of composition. For
example, by a mere configuration change of init, the application could be
started directly by the init component and would thereby not be subjected to
the launcher.


Services and sessions
~~~~~~~~~~~~~~~~~~~~~

The primary purpose of the parent interface is the establishment
of communication channels between components. Any component can inform
its parent about a service that it provides. In order to provide a service,
a component needs to create an RPC object implementing the so-called
_root interface_. The root interface offers functions for creating
and destroying sessions of the service. Figure [img/announce] shows a
scenario where the GUI component announces its service to the init component.
The announce function takes the service name and the capability for the
service's root interface as arguments. Thereby, the root capability is
delegated from the GUI to init.

[tikz img/announce]
  The GUI component announces its service to its parent using the parent
  interface.

It is up to the parent what to do with the announced information. The
parent may ignore the announcement or remember that the child "GUI" provides
a service "GUI". A component can announce any number of services by
subsequent announce calls.

[tikz img/session_request]
  The application requests a GUI session using the parent interface.

The counterpart of the service announcement is the creation of a session by
a client by issuing a _session_ request to its parent. Figure
[img/session_request] shows the scenario where the application requests a
"GUI" session. Along with the session call, the client specifies the
name of the service and a number of session arguments. The session arguments
enable the client to inform the server about various properties of the
desired session. In the example, the client informs the server that it
is interested in reading user input and that the client's window should be
labeled with the name "browser". As a result of a session request, the
client expects to obtain a capability to an RPC object that implements
the session interface of the requested service. Such a capability is called
_session capability_.

When the parent receives a session request from a child, it is free to take
a policy decision of how to respond to the request. There are several
options.

* The parent may deny the request and thereby prevent the child from using
  a particular service.

* The parent could decide
  to implement the requested service by itself by handing out a session
  capability to a locally implemented RPC object to the child.

* If the parent has received an announcement of the service from another
  child, it may decide to direct the session request to the other child.

* The parent may decide to request a session in the name of its child from
  its own parent.

The figure illustrates the latter option where the
launcher responds to the session request by the application by
issuing a session request from its parent, the init component. Note that by
requesting a session in the name of its child, the launcher is able to
modify the session arguments according to its policy. In the example,
the launcher imposes the use of a different label to the session. When
init receives the session request from the launcher, it is up to the init
to take a policy decision with the same principle options. In fact, each
component that sits in between the client and the server along the branches
of the ownership tree can impose its policy to sessions. The routing of the
session request and the final session arguments as received by the server are
the result of the successive application of all policies along the route.

[tikz img/session_root]
  Session creation at the server.

In the example, init decides to override the "input" argument.
Because the GUI announced its "GUI" service beforehand, init is in possession
of the root capability, which enables it to create and destroy GUI
sessions. It decides to respond to the launcher's session request by
triggering the GUI session creation at the GUI component's root interface.
The GUI component responds to this request with the creation of a new GUI
session and attaches the received session arguments to the new session.
The accumulated session policy is thereby tied to the session's RPC object.
The RPC object is accompanied with its corresponding session capability,
which is delegated along the entire call chain up to the originator of the
session request (Section [Delegation of authority and ownership]). Once the
application's session request returns, the application can interact directly
with the GUI session using the session capability.

The differentiation between session creation and session use aligns two
seemingly conflicting goals with each other, namely efficiency and the
application of the security policies of potentially many components. On the
one hand, all components on the route between client and server are involved
in the creation of the session and thereby can impose their policies on the
session. On the other hand, once established, the direct communication channel
between client and server via the session capability allows for the efficient
interaction between the two components. For the actual use of the session, the
intermediate components are not on the performance-critical path.


Client-server relationship
~~~~~~~~~~~~~~~~~~~~~~~~~~

Whereas the role of a component as a child is dictated by the strict
ownership relation that implies that the child has to ultimately trust
its parent, the role of a component as client or server is more diverse.

In its _role of a client_ that obtained a session capability as result of a
session request from its parent, a component is unaware of the real identity
of the server. It is unable to judge the trustworthiness of the server.
However, it obtained the session from its parent, which the client ultimately
trusts. Whichever session capability was handed out by the parent, the client
is not in the position to question the parent's decision.

However, even though the integrity of the session capability can be taken for
granted, the client does not need to trust the server in the same way as it
trusts its parent. By invoking the capability, the client is in full control
over the information it reveals to the server in the form of RPC arguments.
The confidentiality of its internal state is protected. Furthermore, the
invocation of a capability cannot have side effects to the client's protection
domain other than the retrieval of RPC results. So the integrity of the
client's internal state is protected. However, when invoking a capability, the
clients hands over the flow of execution to the server. The client is blocked
until the server responds to the request. A misbehaving server may never
respond and thereby block the client infinitely. Therefore, with respect to
the liveliness of the client, the client has to trust the server. To empathize
with the role of a component as a client, a capability invocation can be
compared to the call of a function of an opaque 3rd-party library. When
calling such a library function, the caller can never be certain to regain
control. It just expects that a function returns at some point. However, in
contrast to a call of a library function, a capability invocation does not put
the integrity and confidentiality of the client's internal state at risk.

If being in the _role of a server_, a component should generally not trust
its clients. In contrary, from the server's perspective, clients should be
expected to misbehave. This has two practical implications. First, a server is
responsible to validate the arguments of incoming RPC requests. Second, a
server should never make itself dependent on the good will of its clients.
For example, a server should generally not invoke a capability obtained
from one of its clients. A malicious client could have delegated a
capability to a non-responding RPC object, which may block the server
forever when invoked and thereby make the server unavailable for all other
clients. As another example, the server must always be in control
over the physical memory resources used for a sharing-memory interface between
itself and its clients. Otherwise, if a client was in control over the
used memory, it could revoke the memory from the server at any time, possibly
triggering a fault at the server. The establishment of shared memory is
described in detail in Section [Shared memory].
Similarly to the role as client, the internal state of a server is protected
from its clients with respect to integrity and confidentaliy.
In contrast to a client, however, the lifeliness of a server is protected as
well. A server does never need to wait for any response from a client.
By responding to an RPC request, the server does immediately become ready
to accept the next RPC request without any prior handshake with the client
of the first request.

Regarding the lifetime of a session, the client is not in the immediate
position to dictate the server when to close a session because it has no power
over the server. Instead, the procedure of closing a session follows the same
chain of commands as involved at the session creation. The common parent of
both client and server plays the role of a broker, which is trusted by both
parties. From the client's perspective, closing a session is a request to its
parent and it is up to the policy of the parent to respond to such a request.
From the server's perspective, the request to close a session originates from
its parent, which, as the owner of the server, represents an authority that
must be ultimately obeyed. Otherwise, the parent of a server might take steps
to enforce its will by destructing the server altogether.


Application-specific trusted computing base
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

| TODO
| * Trusted != trustworthy
| * Tailoring the TCB
| * Resolving mutual distrust


| TODO Resource accounting
| * Assignment
| * Trading of resources
| * Heap partitioning
| * Session upgrades

| TODO Parent interface
| * Dynamic resource balancing

| TODO Root interface


Core - the root of the component tree
=====================================

| TODO

* Physical memory allocation
* Introduction of the services provided by core
  * LOG
  * RAM
  * CAP
  * CPU
  * IO_MEM
  * IO_PORT
  * IRQ
  * PD
  * ROM
  * RM
  * SIGNAL
  * TRACE
* Bootstrapping

Component creation
==================

| TODO

Inter-component communication
=============================

| TODO

Synchronous remote procedure calls (RPC)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Asynchronous notifications
~~~~~~~~~~~~~~~~~~~~~~~~~~

Shared memory
~~~~~~~~~~~~~

Synchronous bulk transfer
~~~~~~~~~~~~~~~~~~~~~~~~~

Asynchronous bulk transfer - packet streams
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


