Components
##########

The architecture introduced in Chapter [Architecture] clears the way to
compose sophisticated systems out of many building blocks. Each building
block is represented by an individual component that resides in a dedicated
protection domain and interacts with other components in a well-defined manner.
Those components do not merely represent applications but all typical
operating-system functionalities.

Components can come in a large variety of shape and form.
Compared to a monolithic operating-system kernel, a component-based operating
system challenges the system designed by enlarging the design space by the
decision of the functional scope of each component and thereby the granularity
of componentization. This decision depends on several factors:

:Security:
  The smaller a component, the lower the risk for bugs and vulnerabilities.
  The more rigid a component's interfaces, the smaller its attack surface
  becomes.
  Hence, the security of a complex system function can potentially be vastly
  improved by splitting it into a low-complexity component that encapsulates
  the security-critical part and a high-complexity component that is
  uncritical for security.

:Performance:
  The split of functionality into multiple components introduces
  inter-component communication and thereby context-switch overhead.
  If a functionality is known to be critical for performance, such a split
  should be clearly motivated by a benefit for security.

:Reusability:
  Componentization can be pursued for improved reusability while sometimes
  disregarding performance considerations. However, reusability can also be achieved by
  moving functionality into libraries that can be easily reused by linking
  them directly against library-using components. By using a dynamic linker,
  the linking can even happen at run time, which yields the same flexibility
  as the use of multiple distinct components. Therefore, the split of
  functionality into multiple components for the sole sake of modularization
  is to be questioned.

The Sections [Device drivers], [Protocol stacks], [Resource multiplexers], and
[Runtime environments] aid the navigation within the componentization design
space by discussing the different roles a component can play within a Genode
system.
Those can be be the role of a device driver, protocol stack, resource
multiplexer, runtime environment, and that of an application. By
distinguishing those roles, it becomes possible to assess the possible
security implications of each individual component.

The versatility of a component-based systems does not come from the
existence of a many components alone. Even more important is the
composability of components. Components can be combined only if their
interfaces match. To maximize composability, the number of interfaces
throughout the system should be as low as possible, and all interfaces
should be largely orthogonal to each other.
Section [Common session interfaces] reviews Genode's common session
interfaces.

Components can be used in different ways depending on their configuration and
their position within the component tree. Section [Component configuration]
explains how a component obtains and processes its configuration.
Section [Component compositions] discusses the most prominent options of
composing components.


Device drivers
==============

A device driver translates a device interface to a Genode session interface.
Figure [img/device_driver] illustrates the typical role of a device driver.

[tikz img/device_driver]
  A network device driver provides a NIC service to a single client and uses
  core's IO-MEM and IRQ services to interact with the physical network adaptor.

; Raw device access

The device interface is defined by the device vendor and typically
comprises the driving of state machines of the device, the
notification of device-related events via interrupts, and a means to
transfer data from and to the device.
A device-driver component accesses the device interface via sessions to the
core services IO_MEM, IO_PORT, and IRQ as described in
Section [Access to device resources (IO_MEM, IO_PORT, IRQ)].

; Translator, not multiplexer

In general, a physical device cannot safely be driven by multiple users at the
same time. If multiple users accessed one device concurrently, the device
state would eventually become inconsistent.
A device driver should not attempt to multiplex device.
Instead, to keep its complexity low, it should act as a server that serves
only a single client per physical device.
Whereas a device driver for a simple device usually accepts only one client,
a device driver for a complex device with multiple sub devices (such as
an USB driver) may hand out each sub device to a different client.

; Void of built-in policy but enforces policy

A device driver should be largely void of built-in policy. If it merely
translates the interface of a single device to a session interface, there is
not much room for policy anyway. If, however, a device driver hands out
multiple sub devices to different clients, the assignment of sub devices
to clients must be subjected to a policy. In this case, the device driver
should obtain this policy information from its configuration as provided by
the driver's parent component.


Platform driver
~~~~~~~~~~~~~~~

There are three problems that are fundamentally important for a running an
operating system on modern hardware but that lie outside the scope of a
ordinary device driver because they are affect the platform as a whole rather
than a single device. Those problems are the enumeration of devices, the
discovery of interrupt routing, and the initial setup of the platform.


Device enumeration
------------------

Modern hardware platforms are rather complex and vary a lot. For example,
the devices attached to the PCI bus of a PC are usually not known at the
build time of the system but need to be discovered at run time. Technically,
each individual device driver could probe its respective device at the
PCI bus. But in the presence of multiple drivers, this approach would not
work. First, the configuration interface of the PCI bus is a device itself.
The concurrent access to the PCI configuration interface by multiple drivers
would ultimately yield undefined behaviour. Second, if each driver spoke
directly to the PCI configuration interface, each driver would need to
carry with it the functionality to interact with PCI.


Interrupt routing
-----------------

On PC platforms with multiple processors, the use of legacy interrupts as
provided by the Intel 8259 programmable interrupt controller (PIC) is not
suitable because, among several other reasons, there is no way to express the
assignment of interrupts to CPUs. To overcome the limitations of the PIC,
Intel introduced the Advanced Programmable Interrupt Controller (APIC). The
APIC, however, comes with a different name space for interrupt numbers, which
creates an inconsistency between the numbers provided by the PCI configuration
(interrupt lines) and interrupt numbers as understood by the APIC. The
assignment of legacy interrupts to APIC interrupts is provided by tables
provided by the Advanced Configuration and Power Interface (ACPI).
Consequently, in order to support multi-processor PC platforms, the operating
system needs to interpret those tables. Within a component-based system, we
need to answer the question of which component is responsible to interpret the
ACPI tables and how this information is applied to the individual device
drivers.


Initial hardware setup
----------------------

In embedded systems, the interaction of the SoC (system on chip) with its surrounding
peripheral hardware is often not fixed in hardware but rather a
configuration issue. For example, the power supply and clocks of certain
peripherals may be enabled by speaking an I2C protocol with a separate
power-management chip. Also, the direction and polarity of the general-purpose
I/O pins depends largely on the way how the SoC is used. Naturally, such
hardware setup steps could be performed by the kernel. But this would require
the kernel to become aware of potentially complex platform intrinsics.


Central platform driver
-----------------------

The natural solution to these problems is the introduction of a so-called
platform driver, which encapsulates the peculiarities outlined above. On PC
platforms, the role of the platform driver is played by the ACPI driver. The
ACPI driver provides an interface to the PCI bus in the form of a PCI service.
Device drivers obtain the information about PCI devices by creating a PCI
session at the ACPI driver. Furthermore, the ACPI driver provides an IRQ
service that transparently applies the interrupt routing based on the
information provided by the ACPI tables. Furthermore, the ACPI driver provides
the means to allocate DMA buffers, which is further explained in Section
[Direct memory access (DMA) transactions].

On ARM platforms, the corresponding component is named platform driver
and provides a so-called platform service. Because of the large variety of
ARM-based SoCs, the session interface for this service differs from platform
to platform.


Interrupt handling
~~~~~~~~~~~~~~~~~~

Most device drivers need to respond to sporadic events produced by the
device and propagated to the CPU as interrupts. In Genode, a device-driver
component obtains device interrupts via core's IRQ service introduced in
Section [Access to device resources (IO_MEM, IO_PORT, IRQ)]. On PC platforms,
device driver usually do not use core's IRQ service directly but rather
use the IRQ service provided by the platform driver
(Section [Platform driver]).

; XXX sequence diagram of handling an interrupt?


Direct memory access (DMA) transactions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Devices that need to transfer large amounts of data usually support a means
to issue data transfers from and to the system's physical memory
without the active participation of the CPU. Such transfers are called
_direct memory access (DMA) transactions_. DMA transactions relieve the CPU
from actively copying data between device registers and memory, optimize
the throughput of the system bus by the effective use of burst transfers, and
may even be used to establish direct data paths between devices.
However, the benefits of DMA transaction come at the risk of corrupting
the physical memory by misguided DMA transactions.
Because those DMA-capable devices can issue bus requests
targeting the physical memory directly and not involving the CPU altogether, such requests
are naturally not subjected by the virtual-memory mechanism implemented in the
CPU in the form of a memory-management unit (MMU).
Figure [img/no_iommu] illustrates the problem. From the device's point of
view, there is just physical memory.
Hence, if a driver sets up a DMA transaction, e.g., if a disk driver reads a
block from the disk, the driver programs the memory-mapped registers of the
device with the address and size of a physical-memory buffer where it expects
to receive the data.
If the driver lives in a user-level component, as is the case for a
Genode-based system, it still needs to know the physical address of the DMA
buffer to program the device correctly.
Unfortunately, there is nothing to prevent the driver from specifying any
physical address to the device.
Consequently, a malicious driver could misuse the device to read and
manipulate all parts of the physical memory, including the kernel.
Consequently, device drivers and devices should ideally be trustworthy.
However, there are several situations where this is ultimately not
the case.

[tikz img/no_iommu 100%]
  The MMU restricts the access of physical memory pages by different
  components according to their virtual address spaces.
  However, direct memory accesses issued by the disk controller are not
  subjected to the MMU. The disk controller can access the entirety of the
  physical memory present in the system.


Direct device assignment to virtual machines
--------------------------------------------

When hosting virtual machines as Genode components, the direct assignment of
a physical device such as a USB controller, a GPU, or a dedicated network
card to the guest OS running in the virtual machine can be
useful in two ways. First, if the guest OS is the sole user of the device,
the direct assignment of the device maximizes the I/O performance of the
guest OS using the device. Second, the guest OS may be equipped with a
proprietary device driver that is not present as a Genode component otherwise.
In this case, the guest OS may be used as a runtime executing the device
driver and providing a driver interface to the Genode world. In both cases
the guest OS should not be considered as trustworthy.
In contrary, it bears the risk to subvert the isolation between components.
A misbehaving guest OS could issue DMA requests referring
to the physical memory used by other components and even the kernel and
thereby break out of its virtual machine.


Firmware-driven attacks
-----------------------

Modern peripherals such as wireless LAN adaptors, network cards, or GPUs
employ firmware executed on the peripheral device. This firmware is executed
on a microcontroller on the device, and is thereby not subjected to the
policy of the normal operating system. Such firmware may either be built-in
by the device vendor, or is loaded by the device driver at initialization
time of the device. In both cases, the firmware tends to be a black box
that remains obscure except for the device vendor. Hence, hidden functions
or vulnerabilities might be present in it. By the means of DMA transactions, such
firmware has unlimited access on the system. For example, a back door
implemented in the firmware of a network adaptor could look for
special network packets to activate and control arbitrary spyware functions.
Because malware embedded in the firmware of the device can neither be detected
nor controlled by the operating system, both monolithic and microkernel-based
operating systems are powerless against such attacks.


Bus-level attack
----------------

The previous examples misused a DMA-capable device as a proxy to drive an
attack. However, the system bus can be attacked directly with no hardware
tinkering needed. There are ready-to-exploit interfaces that featured on most
PC systems. For example, most laptops come with PCMCIA / ExpressCard slots,
which allow expansion cards to access the system bus. Furthermore, serial bus
interfaces, i.e., IEEE 1394 (Firewire) enable connected devices to indirectly
access the system bus via the peripheral bus controller. If the bus controller
allows the device to issue direct system bus requests by default, any connected
device becomes able to gain control over the whole system. This vulnerability
has been present on a wide range of commodity computers.


DMA transactions in component-based systems
-------------------------------------------

Direct memory access (DMA) of devices looks like the Achilles
heel of component-based operating systems. The most compelling argument in
favour of componentization is that by encapsulating each system component
within a dedicated user-level address space, the system as a whole becomes more
robust and secure compared to a monolithic operating-system kernel. In the
event that one component fails due to a bug or an attack, other components
remain unaffected. The prime example for such buggy components are, however, device
drivers. By empirical evidence, those remain the most prominent trouble makers
in today's operating systems, which suggests that the DMA loophole renders
the approach of component-based systems largely ineffective.
However, there are three counter arguments to this observation.

[tikz img/iommu]
  An IOMMU arbitrates and virtualizes DMA accesses issued by a device to the
  RAM. Only if a valid IOMMU mapping exists for a given DMA access, the memory
  access is performed.

First, by encapsulating each driver in a dedicated address space,
classes of bugs that are unrelated to DMA remain confined in the
driver component. In practice most driver-related problems stem from issues like
memory leaks, synchronization problems, deadlocks, flawed driver logic, wrong
state machines, or incorrect device-initialization sequences. For those classes
of problems, the benefits of isolating the driver in a dedicated component
still applies.

Second, executing a driver largely isolated from other operating-system code
minimizes the attack surface onto the driver. If the driver interface is
rigidly small and well-defined, it is hard to compromise the driver by
exploiting its interface.

Third, modern PC hardware has closed the DMA loophole by incorporating
so-called IOMMUs into the system. As depicted in Figure [img/iommu], the IOMMU
sits between the physical and the system bus where the devices are attached to.
So each DMA request has to pass the IOMMU, which is not only able to arbitrate
the access of DMA requests to the RAM but also able to virtualize the address
space per device. Similar to how a MMU confines each process running on the
CPU within a distinct virtual address space, the IOMMU is able to confine each
device within a dedicated virtual address space. To tell the different devices
apart, the IOMMU uses the PCI device's bus-device-function triplet as unique
identification.

With an IOMMU in place, the operating system can effectively limit the scope
of actions the given device can execute on the system. I.e., by restricting
all accesses originating from a particular PCI device to the DMA buffers used
for the communication, the operating system becomes able to detect and prevent
any unintended bus accesses initiated by the device.

When executed on the NOVA kernel, Genode subjects all DMA transactions to the
IOMMU, if present. Section [IOMMU support] discusses the use of IOMMUs in
more depth.


Protocol stacks
===============

[tikz img/protocol_stack]
  Example of a protocol stack. The terminal provides the translation between
  the terminal-session interface (on the right) and the driver interfaces
  (on the left).

A protocol stack _translates_ one session interface to another (or the same)
session interface. For example, a terminal component may provide a command-line
application with a service for obtaining textual user input and
printing text.
To implement this service, the terminal uses an input session and a
framebuffer session. Figure [img/protocol_stack] depicts the relationship
between the terminal, its client application, and the used drivers.
For realizing the output of a stream of characters on
screen, it implements a parser for escape sequences, maintains a state machine
for the virtual terminal, and renders the pixel representation of characters
onto the framebuffer. For the provisioning of textual user input, it responds
to key presses reported by the input session, maintains the state of modifier
keys, and applies a keyboard layout to the stream of incoming events.
When viewed from the outside the component, the terminal translates a terminal
session to a framebuffer session and an input session.

Similar to device drivers, a protocol stack typically serves a single client.
In contrast to device drivers, however, protocol stacks are not bound to
physical devices. Therefore, a protocol stack can be instantiated any number
of times. For example, if multiple terminals are needed, one terminal
component could be instantiated per terminal. Because each terminal has an
independent instance of the protocol stack, a bug in the protocol stack of one
terminal does affect any other terminal. However complex the implementation of
the protocol stack may be, it is not prone to leaking information to another
terminal because it is connected to a single client only. The leakage of
information is constrained to interfaces used by the individual instance.
Hence, protocol stacks appear often as the most suitable category of
components to host highly complex untrusted code if needed.

Note that the example above cannot be generalized. There are protocol stacks
that are critical for the confidentiality of information. For example, an
in-band encryption component may translate plain-text network traffic to
encrypted network traffic designated to be transported over a public network.
Even though the component is a protocol stack, it may still be prone to
leaking unencrypted information to the public network.

Whereas protocol stacks are not necessarily critical for integrity and
confidentiality, they are almost universally critical for availability.


Resource multiplexers
=====================

[tikz img/resource_multiplexer]
  A GUI server multiplexes the physical framebuffer and input devices among
  multiple applications.

A resource multiplexer transforms one resource into a number of virtual
resources. A resource is typically a session to a device driver. For
example, a NIC-switch component may use one NIC session to a NIC driver
as uplink and, in turn, provide a NIC service where each session represents
a virtual NIC. Another example is a GUI server as depicted in Figure
[img/resource_multiplexer], which enables multiple applications to share
the same physical framebuffer and input devices by presenting each
client in a window or a virtual console.

In contrast to a typical device driver or protocol stack that serves only a
single client, a resource multiplexer is shared by potentially many clients.
In the presence of untrusted clients besides security-critical clients,
a resource multiplexer ultimately becomes a so-called _multi-level_ component.
This term denotes that the component is cross-cutting the security levels
of all its clients. This has the following ramifications.

:Covert channels:
  Because the component is a shared resource that is accessed by clients
  of different security levels, it must maintain the strict isolation
  between its clients unless explicitly configured otherwise. Hence, the
  component's client interface as well as the internal structure must be
  designed to prevent the leakage of information across clients. I.e.,
  two clients must never share the same namespace of server-side objects
  if such a namespace can be modified by the clients. For example, a window
  server that hands out global window IDs to its clients is prone to
  unintended information leakage because one client could observe the
  allocation of window IDs by another client. The ID allocation could be
  misused as a covert channel that circumvents security policies.
  In the same line, a resource multiplexer is prone to timing channels if
  the operations provided via its client interface depends on the behavior
  of other clients. For this reason, blocking RPC calls should be avoided
  because the duration of a blocking operations may reveal information about
  the internal state such as the presence of other clients of the resource
  multiplexer.

:Complexity is dangerous:
  As a resource multiplexer is shared by clients of different security
  levels, the same considerations apply as for the OS kernel: High complexity
  poses a high risk for bugs. Such bugs may, in turn, result in the
  unintended flow of information between clients or spoil the quality of
  service for all clients. Hence, resource multiplexers must be as low complex
  as possible.

:Denial of service:
  The exposure of a resource multiplexer to untrusted and even malicious
  clients makes it a potential target for denial-of-service attacks.
  Some operations provided by the resource multiplexer may require the
  allocation of memory. For example, a GUI server may need to memory for
  the book keeping of each window created its clients.
  If the resource multiplexer performed such allocations from its own
  memory budget, a malicious client could trigger the exhaustion of
  server-side memory by creating new windows in an infinite loop.
  To mitigate this category of problems, a resource multiplexer should perform
  memory allocations exclusively from client-provided resources, i.e., using
  the session quota as provided by each client at the session-creation time.
  Section [Resource trading] describes Genode's resource-trading mechanism
  in detail.

:Avoiding built-in policies:
  A resource multiplexer can be understood as a microkernel for a higher-level
  resource. Whereas a microkernel multiplexes or arbitrates the CPU and
  memory between multiple components, a resource multiplexer does the same
  for sessions.
  Hence, the principles for constructing microkernels equally apply for
  resource multiplexers.
  In the line of those principles, a resource multiplexer should ideally
  implement sole mechanisms but should be void of built-in policy.

:Enforcement of policy:
  Instead of providing a built-in policy, a resource multiplexer obtains
  policy information from its configuration as supplied by its parent.
  The resource multiplexer must enforce the given policy. Otherwise, the
  security policy defined by the parent remains ineffective.

| Server-side heap partitioning
| (illustration of anonymous memory allocations)


Runtime environments and applications
=====================================

The component types discussed in the previous sections have in common that
they deliberately lack built-in policy but act according to a policy
supplied by their respective parents by the means of configuration.
This raises the question where those policies should come from.
The answer comes in the form of runtime environments and applications.

[tikz img/runtime_environment]
  A runtime environment manages multiple child components.

A _runtime environment_ as depicted in Figure [img/runtime_environment]
is a component that hosts child components.
As explained in the Sections [Recursive system structure] and
[Resource trading], it is thereby able to exercise control over its children
but is also responsible to manage the children's resources.
A runtime environment controls its children in three ways:

:Session routing:
  It is up to the runtime environment to decide how to route session
  requests originating from a child.
  The routing of sessions is discussed in Section [Services and sessions].

:Configuration:
  Each child obtains its configuration from its parent in the form of
  a ROM session. Using this mechanism, the runtime environment is able to feed
  policy information to its children. Of course, in order to make the policy
  be effective, the respective child has to interpret and enforce the
  configuration accordingly.

:Lifetime:
  The lifetime of a child ultimately depends on its parent. Hence, a
  runtime environment can destroy and possibly restart child components
  at any time.

With regard to management of child resources, a runtime environment can employ
a large variety of policies using two principal approaches:

:Quota management:
  Using the resource trading mechanisms introduced in Section
  [Resource trading], the runtime environment can assign resources to
  each child individually. Moreover, if a child supports the dynamic
  rebalancing protocol described in Section [Dynamic resource balancing],
  the runtime environment may even change those assignments over the lifetime
  of its children.

:Interposing services:
  Because the runtime environment controls the session routing of each
  child, it is principally able to interpose the child's use of any service
  including those normally provided by core such as
  RAM (Section [Physical memory allocation (RAM)]),
  RM (Section [Address-space management (RM)]), and
  CPU (Section [Processing-time allocation (CPU)]).
  The runtime environment may provide a locally implemented version of those
  session interfaces instead of routing session requests directly towards the
  core component.
  Internally, each session of such a local service may create a session to the
  real core service, thereby effectively wrapping core's sessions.
  This way, the runtime environment can not only observe the interaction of
  its child with core services but also implement custom resource-management
  strategies, for example, sharing one single budget among multiple children.

Canonical examples of runtime environments are the init component that
applies a policy according to its configuration, the noux runtime that
presents itself as a Unix kernel to its children, a debugger that
interposes all core services for the debugging target, or a virtual machine
monitor.

A typical _application_ is a leaf node in the component tree that merely uses
services. In practice, however, the boundary between applications and runtime
environments can be blurry.
As illustrated in Section [Component compositions], Genode fosters the
internal split of applications into several components, thereby forming
_multi-component applications_.
From the outside, such a multi-component application appears as leaf node of
the component tree but internally, it employs a further level of
componentization by executing portions of its functionality in separate child
components.
The primary incentive behind this approach is the sandboxing of untrusted
application functionality. For example, a video player may execute the video
codec within a separate child component so that a bug in the complex video
codec will not compromise the entire video-player application.


Common session interfaces
=========================

The core services described in Section [Core - the root of the component tree]
principally enable the creation of a recursively structured system. However,
their scope is limited to the few low-level resources provided by core, namely
processing time, memory, and low-level device resources. Device drivers
(Section [Device drivers]) and protocol stacks (Section [Protocol stacks])
transform those low-level resources into higher-level resources. Analogously
how core's low-level resources are represented by the session interfaces
of core's services, higher-level resources are represented by the session
interfaces provided by device drivers and protocol stacks. In principle,
each device driver could introduce a custom session interface representing
the particular device.
But as discussed in the introduction of Chapter [Components], a low
number of orthogonal session interfaces is desirable to maximize the
composability of components.
This section introduces the common session interfaces that are used throughout
Genode.


Read-only memory (ROM)
~~~~~~~~~~~~~~~~~~~~~~

The ROM session interface makes a piece of data in the form of a dataspace
available to the client.


Session creation
----------------

At session-creation time, the client specifies the name of a ROM module as
session argument. So one server may hand out a different ROM modules depending
on the specified name. Once a ROM session has been created, the client can
request the capability of the dataspace that contains the ROM module.
Using this capability and the client's RM session, the client can attach
the ROM module to its local address space and thereby access the information.
The client is expected to merely read the data, hence the name of the
interface.


ROM module updates
------------------

In contrary to the intuitive assumption that read-only data is constant,
ROM modules may mutate during the lifetime of the session. The server may
update the content of the ROM module with new versions. However, the server
does not do so without the consent of the client. The protocol between
client and server consists of the following steps.

# The client registers a signal handler at the server to indicate that it
  is interested in receiving updates of the ROM module.

# If the server has a new version of the ROM module, it does not immediately
  change the dataspace shared with the client. It rather maintains the
  new version separately and informs the client by submitting a signal to
  the client's signal handler.

# The client continues working with the original version of the dataspace.
  Once it receives the signal from the server, it may decide to update the
  dataspace by calling an _update_ function at the server.

# The server responds to the update request. If the new version fits into
  the existing dataspace, the server copies the content of the new version
  into the existing dataspace and returns this condition in the reply of the
  update call. Hence, the ROM session interface employs synchronous bulk
  transfers as described in Section [Synchronous bulk transfer].

# The client evaluates the result of the update call. If the new version
  has fit in the existing dataspace, the update is complete at this point.
  However, if the new version is larger than the existing dataspace, the
  client requests a new dataspace from the server.

# On reception of the dataspace request, the server destroys the original
  dataspace (thereby making it invisible at the client), and returns
  the new version of the ROM modules as a different dataspace.

# The client attaches the new dataspace capability at its local address
  space to access the new version.

The protocol is designed such that neither the client nor the server need
to support updates. A server with no support for updating ROM modules such
as core's ROM service simply ignores the registration of a signal handler
by a client. A client that is not able to cope with ROM module updates
never requests the dataspace twice.

However, if both client and server support the update protocol, the ROM
session interface provides a means to propagate large state changes
from the server to the client in a transactional way.
In the common case where the new version of a ROM module fits into the same
dataspace as the old version, the update does not require any memory
mappings to be changed.


Use cases
---------

The ROM session interface is used wherever data shall be accessed in a memory
mapped fashion.

* Boot time data comes in the form of the ROM sessions provided by core's
  ROM service. On some kernels, core exports kernel-specific information
  such as the kernel version in the form of special ROM modules.

* If an executable binary is provided as a ROM module, the binary's text
  segment can be attached directly to the address space of a new process.
  So multiple instances of the same component effectively share the same
  text segment.
  The same holds true for shared libraries. For this reason, executable
  binaries and shared libraries are requested in the form of ROM sessions.

* Components obtain their configuration by requesting a ROM session for the
  ROM module "config" at the parent. This way, configuration information
  can be propagates using a simple interface with no need for a file
  system. Furthermore, the update mechanism allows the parent to dynamically
  change the configuration of a component during its lifetime.

* As described in Section [Publishing and subscribing], multi-component
  applications may obtain data models in the form of ROM sessions. In such
  scenarios, the ROM session's update mechanism is used to propagate
  model updates in a transactional way.


Report
~~~~~~

The report session interface allows a client to report internal state to
its parent using synchronous bulk transfers
(Section [Synchronous bulk transfer]).

Session creation
----------------

At session-creation time, the client specifies a label and a buffer size.
The label aids the routing of the session request but may also be used
to select a policy at the report server. The buffer size determines the
size of the dataspace shared between the report server and client.

Use cases
---------

* Components may use report sessions to export their internal state for
  monitoring purposes or for propagating exceptional events.

* Device drivers may report the information about detected devices or other
  resources. For example, a bus driver may report a list of devices attached
  on the bus, or a wireless driver may report the list of available networks.

* In multi-component applications, components that provide data models
  to other components may use the report-session interface to propagate
  model updates.


Terminal and UART
~~~~~~~~~~~~~~~~~

The terminal session interface provides a bi-directional communication
channel between client and server using synchronous bulk transfers
(Section [Synchronous bulk transfer]). It is primarily meant for textual
user interfaces but may also be used to transfer other serial steams of
data.

The interface uses the two RPC functions _read_ and _write_ to arbitrate
the access to a shared-memory communication buffer between client and server
as described in Section [Synchronous bulk transfer]. The read function does
never block. When called, it copies new input into the communication buffer
and returns the number of new characters. If there is not new input, it
returns 0. To avoid the need to poll for new input at the client side, the
client can register a signal handler that gets notified on the arrival of
new input. The write function takes a number of to-be-written characters
as argument. The server responds to this function by processing the specified
amount on characters from the communication buffer.

Besides the actual read and write operations, the terminal supports the
querying of the number of new available input (without reading it) and the
terminal size in rows and columns.


Session creation
----------------

At session-creation time, the terminal session may not be ready to use.
For example, a TCP terminal session needs an established TCP connection first.
In such a situation, the use of the terminal session by a particular client
must be deferred until the session becomes ready.
Delaying the session creation at the server side is not an option because this
this would render the server's entry point unavailable for all other clients
until the TCP connection is ready.
Instead, the server delivers a 'connected' signal to the client. This signal
is emitted when the session becomes ready to use. The client waits for this
signal right after creating the session.


Use cases
---------

* Device drivers that provide streams of characters in either direction
* Graphical terminal
* Transfer of steams of data over TCP (using TCP terminal)
* Writing streams of data to a file (using file terminal)
* User input and output of traditional command-line based software, i.e.,
  programs executed within the noux environment
* Multiplexing of multiple textual user interfaces (using the terminal-mux
  component)
* Headless operation and management of subsystems (using CLI monitor)


UART
----

The UART session interface complements the terminal session interface with
additional control functions, e.g., for setting the baud rate. Because UART
sessions are compatible to terminal sessions, a UART device driver can be
used as both UART server and terminal server.


Input
~~~~~

The input session interface is used to communicate low-level user-input
events from the server to the client using synchronous bulk transfers
(Section [Synchronous bulk transfer]). Such an event can be of one of the
following types:

:press or release: of a button or key. Each physical button (such as a mouse
  button) or key (such as a key on a keyboard) is represented by a unique
  value. At the input-session level, key events are reported as raw hardware
  events. They are reported without a keyboard layout applied and without any
  interpretation of meta keys (like shift, alt, and control). This gives the
  client the flexibility to handle arbitrary combination of keys.

:relative motion: of pointer devices such as a mouse. Such events are
  generated by device drivers.

:absolute motion: of pointer devices such as a touch screen or graphics
  tablet. Furthermore absolute motion events are generated by virtual
  input devices such as the input session provided by a GUI server.

:wheel motion: of scroll wheels in vertical and horizontal directions.

:focus: of the session. Focus events are artificially generated by servers
  to indicate a gained or lost keyboard focus of the client. The client
  may respond to such an event by changing its graphical representation
  accordingly.

:leave: of the pointer position. Leave events are artificially generated
  by servers to indicate a lost pointer focus to the client.


Use cases
---------

* Drivers for user-input devices play the roles of input servers
* Providing user input from a GUI server to its clients, i.e., the
  interface of the nitpicker GUI server provides an input session as part
  of the server's interface.
* Merging multiple streams of user input into one stream (using an input
  merger)
* Virtual input devices can be realized as input servers that generate
  artificial input events.


Framebuffer
~~~~~~~~~~~

The framebuffer session interface allows a client to supply pixel data to
a framebuffer server such as a framebuffer driver or a virtual framebuffer
provided by a GUI server. The client obtains access to the framebuffer as
a dataspace, which is shared between client and server. The client may
update the pixels within the dataspace at any time. Once, a part of the
framebuffer has been updated, the client informs the server by calling a
_refresh_ RPC function. Thereby, the framebuffer session interface employs a
synchronous bulk transfer mechanism (Section [Synchronous bulk transfer]).


Session creation
----------------

In general, the screen mode is defined by the framebuffer server, not the
client. The mode may be constrained by the physical capabilities of the
hardware or depend on the driver configuration. Some framebuffer servers,
however, may take a suggestion by the client into account. At session-creation
time, the client may specify a preferred mode as session argument. Once the
session is constructed, however, the client must request the actually used
mode via the _mode_ RPC function.


Screen-mode changes
-------------------

The session interface supports dynamic screen-mode changes during runtime
using the following protocol:

# The client may register a signal handler using the _mode_sigh_ RPC function.
  This handler handler gets notified in the event of server-side mode changes.

# Analogously to the transactional protocol used for updating ROM modules
  (Section [Read-only memory (ROM)]), the dataspace shared between client and
  server stays in tact until the client acknowledges the mode change by calling
  the _mode_ RPC function.

# The server responds to the _mode_ function by applying the new mode and
  returning the according mode information to the client.

# The client requests a new version of the frambuffer dataspace by calling
  the _dataspace_ RPC function and attaches the dataspace to its local
  address space.
  Note that each subsequent call of the dataspace RPC function may result
  in the replacement of the existing dataspace by a new dataspace. Hence,
  calling _dataspace_ twice may invalidate the dataspace returned from the
  first call.


Scanline synchronization
------------------------

To enable framebuffer clients to synchronize their operations with the display
frequency, a client can register a handler for receiving
display-synchronization events as asynchronous notifications
(Section [Asynchronous notifications]).


Use cases
---------

* Framebuffer device drivers are represented as framebuffer servers.
* A virtual framebuffer may provide both the framebuffer and input session
  interfaces by presenting a window on screen. The resizing of the window
  may be reflected to the client as screen-mode changes.
* A filter component requests a framebuffer session and, in turn, provides
  a framebuffer session to a client. This way, pixel transformations can be
  applied to pixels produced by a client without extending the client.


Nitpicker GUI
~~~~~~~~~~~~~

The nitpicker session interface subsumes an input session and a
framebuffer session as a single session. Furthermore it supplements the
framebuffer session with the notion of views, which allows the creation
of flexible multi-window user interfaces. It is generally suited for
resource multiplexers of the framebuffer and input sessions.
A view is a rectangular area on screen that displays a portion of the client's
virtual framebuffer. The position and size of each view is defined by the
client. Views can overlap, thereby creating a view stack. The stacking
order of the views of one client can be freely defined by the client.

The size of the virtual framebuffer can be freely defined by the client
but the required backing store must be provided in the from of session
quota.
Clients may request the screen mode of the physical framebuffer and are
able to register a signal handler for mode changes of the physical
framebuffer. This way, nitpicker clients are able to adapt themselves to
changed screen resolutions.


Use cases
---------

* The nitpicker GUI server allows multiple GUI applications to share a
  pair of a physical framebuffer session and an input session in a secure way
  between multiple GUI applications.
* A window manager implementing the nitpicker session interface may
  represent each view as a window with window decorations and a placement
  policy. The resizing of a windows by the user is reflected to the client as
  a screen-mode change of the physical framebuffer.
* A loader (Section [Loader]) virtualizes the nitpicker session interface for
  the loaded subsystem.


Platform
~~~~~~~~

The platform session interface (on ARM-based devices) and the PCI session
interface (on x86-based machines) provide the client will access to the
devices present in the hardware platform. See Section
(Section [Platform driver]) for more information on the role of platform
drivers.


Block
~~~~~

The block session interface allows a client to access a storage server at
the block level. The interface is based on a packet stream
(Section [Asynchronous bulk transfer - packet streams]). Each packet
represents a block-access command, which can be either read or write.
Thanks to the use of the packet-stream mechanism, the client can issue
multiple commands at once and thereby hide access latencies by submitting
batches of block requests. The server acknowledges each packet after
completing the corresponding block-command operation.

The packet-stream interface for submitting commands is complemented by
the _info_ RPC function for querying the properties of the block device, i.e.,
the supported operations, the block size, and the block count. Furthermore,
a client can call the _sync_ RPC function to flush caches at the block server.


Session creation
----------------

At session-creation time, the client can dimension the size of the
communication buffer as session argument. The server allocates the shared
communication buffer from the session quota.


Use cases
---------

* Block-device drivers implement the block-session interface.
* The part-block component requests a single block session, parses a
  partition table and hands out each partition as a separate block session
  to its clients. There can be one client for each partition.
* File-system servers use block sessions as their back end.


Regulator
~~~~~~~~~

The regulator session represents an adjustable value in the hardware
platform. Examples are runtime-configurable frequencies and voltages.
The interface is a plain RPC interface.


Timer
~~~~~

The timer session interface provides a client with a session-local time
source. A client can use it to schedule timeouts that are delivered as
signals to a prior registered signal handler. Furthermore, the client
can request the elapsed number of milliseconds since the creation of the
timer session.


NIC
~~~

A NIC session represents a network interface that operates at network-packet
level. Each session employs two independent packet streams (Section
[Asynchronous bulk transfer - packet streams], one for receiving network
packets and one for transmitting network packets. Furthermore, the client
can query the MAC address of the network interface.

Session creation
----------------

At session-creation time, dimensions the communication buffers of both
packet streams via session arguments. The communication buffers are
allocated by the server using the session quota provided by the client.

Use cases
---------

* Network drivers are represented as NIC servers.
* A NIC switch uses one NIC session connected to a NIC driver, and provides
  multiple virtual NIC interfaces to its clients by managing a custom
  name space of virtual MAC addresses.
* A TCP/IP stack uses a NIC session as back end.


Audio output
~~~~~~~~~~~~

The audio output interface allows for the transfer of audio data from the
client to the server.
One session corresponds to one channel. I.e., for
stereo output, two audio-out sessions are needed.


Session construction
--------------------

At session-construction time, the client specifies the type of channel
(e.g., front left) as session argument.


Interface design
----------------

For the output of streamed audio data, a codec typically decodes a relatively
large portion of an audio stream and submits the sample data to a mixer. The
mixer, in turn, mixes the samples of multiple sources and forwards the result
to the audio driver. Each of those components the codec, the mixer, and the
audio driver live in separate processes. By using large buffer sizes between
them, there is only very little context-switching overhead. Also, the driver
can submit large buffers of sample data to the sound device without any
further intervention needed.
In contrast, sporadic sounds are used to inform the user about an immediate
event. It is ultimately expected that such sounds are played back without much
latency. Otherwise the interactive experience (e.g., of games) would suffer.
Hence, using large buffers between the audio source, the mixer, and the driver
is not an option.
The audio-out session interface was specifically designed to
accommodate both corner cases of audio output.

Similarly to the packet-stream mechanism described in Section
[Asynchronous bulk transfer - packet streams],
the audio-out session interface employs a combination of shared memory and
asynchronous notifications.
However, in contrast to the packet-stream mechanism, it has no notion of
ownership of packets. When using the normal packet-stream protocol,
either the source or the sink is in charge of handling a given packet at a
given time, not both. The audio-out session interface weakens this notion of
ownership by letting the source update once submitted audio frames even after
submitting them.
If there are solely continuous streams of audio arriving at the mixer,
the mixer can mix those large batches of audio samples at once and pass the
result to the driver.

| XXX figure img/mixer_streaming
; [tikz img/mixer_streaming]
;   The mixer processes incoming data from multiple streaming sources as batches.

Now, if a sporadic sound comes in, the mixer checks the
current output position reported by the audio driver, and re-mixes those
portions that haven't been played back yet by incorporating the sporadic sound.
So the buffer consumed by the driver gets updated with new data.

| XXX figure img/mixer_sporadic
;[tikz img/mixer_sporadic]
;  A sporadic occuring sound prompts the mixer to remix packets that are
;  already submitted in the output queue.

Besides the way of how packets are populated with data, the second
major difference to the packet-stream mechanism its time-triggered
mode of operation. The
driver produces periodic signals that indicate the completeness of a
played-back audio packet. This signal triggers the mixer to become active,
which in turn serves as a time base for its clients. The current playback
position is denoted alongside the sample data as a field in the memory buffer
shared between source and sink.

Use cases
---------

* The audio-out session interface is provided by audio drivers.
* An audio mixer combines incoming audio streams of multiple clients into
  one audio stream transferred to an audio driver.


File system
~~~~~~~~~~~

The file-system session interface provides the client with a storage
facility at the file and directory-level. Compared to the block session
interface (Section [Block]), it operates on a higher abstraction level
that is suited for multiplexing the storage device among multiple clients.
Similar to the block session, the file-system session employs a single
packet stream interface
(Section [Asynchronous bulk transfer - packet streams]_ for issuing read
and write operations. This way, read and write requests can be processed
in batches and even out of order.

In contrast to read and write operations that carry potentially large amounts
of payload, the directory functions provided by the file-system session
interface are synchronous RPC functions. Those functions are used for
opening, creating, renaming, moving, deleting, and querying files,
directories and symbolic links.

The directory functions are complemented with an interface for receiving
notifications upon file or directory changes using asynchronous notifications.

Use cases
---------

* A file-system operates on a block session to provide file-system sessions to
  its clients.
* A RAM file system keeps a directory structure and files in memory and
  provides file-system sessions to multiple clients. Each session may be
  restricted in different ways (such as the root directory as visible by
  the respective client, or the permission to write). Thereby the clients
  can communicate using the RAM file system as a shared storage facility
  but are subjected to an information-flow policy.
* A file-system component may play the role of a filter that transparently
  encrypts the content of the files of its client and stores the
  encrypted files at another file-system server.
* A pseudo file system may use the file-system interface as an hierarchic
  control interface. For example, a trace file system provides a pseudo
  file system as a front end to interact with core's TRACE service.


Loader
~~~~~~

The loader session interface allows clients to dynamically create Genode
subsystems to be hosted as children of a loader service. In contrast to a
component that is spawning a new subsystem as an immediate child, a loader
client has very limited control over the spawned subsystem. It can merely
define the binaries and configuration to start, define the position where the
loaded subsystem will appear on screen, and kill the subsystem. But it is not
able to interfere with the operation of the subsystem during its lifetime.


Session creation
----------------

At session-creation time, the client defines the amount of memory to be
used for the new subsystem as session quota. Once the session is established,
the client equips the loader session with ROM modules that will be presented
to the loaded subsystem. From the perspective of the subsystem, those ROM
modules can be requested in the form of ROM sessions from its parent.


Visual integration of the subsystem
-----------------------------------

The loaded subsystem may implement a graphical user interface by creating
a nitpicker session (Section [Nitpicker GUI]). The loader responds to such a
session request by providing a locally implemented session. The loader
subordinates the nitpicker session of the loaded subsystem to a nitpicker
view (called parent view) defined by the loader client.
The loader client can use the loader session interface to position the view
relative to the parent-view position. Thereby, the graphical user interface
of the loaded subsystem can be seamlessly integrated with the user interface
of the loader client.


Use case
--------

The most illustrative use case is the execution of web-browser plugins where
neither the browser trusts the plugin nor the plugin trusts the browser.


Component configuration
=======================

By convention, each component obtains its configuration in the form of a
ROM module named "config". The ROM session for this ROM module is provided
by the parent of the component. For example, for the init component, which is
the immediate child of core, its "config" ROM module is provided by core's
ROM service. Init, in turn, provides a different config ROM module to each
of its children by providing a locally implemented ROM service per child.


Configuration format
~~~~~~~~~~~~~~~~~~~~

In principle, being a mere ROM module, a component configuration can come in
an arbitrary format. However, throughout Genode, there exists the convention
to use XML as syntax and wrap the configuration within a '<config>' node.
The definition of sub nodes of the configuration depends on the respective
component.


Server-side policy selection
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Servers that serve multiple clients may apply different a different policy
to each client.
In general, the policy may be defined by the session arguments aggregated on
the route of the session request as explained in Section
[Services and sessions].
However, in the usual case, the policy is dictated by the common parent
of client and server. In this case, the parent may propagate its policy
as the server's configuration and deliver a textual label as session argument
for each session requested at the server. The configuration contains a
list of policies whereas the session label is used as a key to select
the policy from the list. For example, the following snippet configures
a RAM file system with different policies.

! <config>
!   <!-- constrain sessions according to their labels -->
!   <policy label="noux -> root" root="/" />
!   <policy label="noux -> home" root="/home/user" />
!   <policy label="noux -> tmp"  root="/tmp" writeable="yes" />
! </config>

Each time a session is created, the server matches the supplied session label
against the configured policies. Only if a policy matches, the parameters of
the matching policy come into effect. The way how the session label is
matched against the policies depends on the implementation of the server.
Usually, the server selects the policy with where the session label starts with
the policy's label. If multiple policies match, the one with the longest (most
specific) policy label is selected. If multiple policies have the same label,
the selection is undefined. This is a configuration error.


Dynamic component reconfiguration at runtime
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As described in Section [Read-only memory (ROM)], a ROM module can be updated
during the lifetime of the ROM session. This principally enables a parent
to dynamically reconfigure a child component without the need to restart it.
If a component supports its dynamic reconfiguration, it installs a signal
handler at its "config" ROM session. Each time, the configuration changes,
the component will receive a signal. It responds to such a signal by obtaining
the new version of the ROM module using the steps described in
Section [Read-only memory (ROM)] and applying the new configuration.


Component compositions
======================

Genode provides a playground for combining components in many different ways.
The best composition of components often depends on the goal of the system
integrator. Among possible goals are the ease of use for the end user, the
cost-efficient reuse of existing software, and good application
performance. However, the most prominent goal is the mitigation of security
risks. This section presents composition techniques that leverage
Genode's architecture to dramatically reduce the trusted computing base of
applications and to solve rather complicated problems in surprisingly easy
ways.


Sandboxing
~~~~~~~~~~

The functionality of existing applications and libraries is often worth
reusing or economically downright infeasible to reimplement. Examples
are PDF rendering engines, libraries that support commonly used video and
audio codecs, or libraries that decode hundreds of image formats.

However code of such a rich functionality is inherently complex and must be
assumed to contain security flaws. This is empirically evidenced by the
never ending stream of security exploits targeting the decoders of data
formats. But even in the absence of bugs, the processing of data by
third-party libraries may have unintended side effects. For example,
a PDF file may contain code that accesses the file system, which the user
of a PDF reader may not expect. By linking such a third-party library to a
security-critical application, the application's security is seemingly traded
against the functional value that the library provides.

; [tikz img/qt_avplay]
;   A video player executes the video and audio codec within a dedicated
;   sandbox.

Fortunately, Genode's architecture principally allows every component to
encapsulate untrusted functionality in child components. So instead of
directly linking a third-party library to an application, the application
executes the library code in a dedicated sub component. By imposing a
strict session-routing policy to the component, the untrusted code is
restricted to its sandbox. Figure [img/qt_avplay] shows a video player as
a practical example of this approach.

A video player uses the nitpicker GUI server to present a user interface
with the graphical controls of the player. Furthermore, it has access to
a media file containing video and audio data.
Instead of linking the media-codec library (libav) directly to video player
application, it executes the codec as a child component. Thereby the
application effectively restricts the execution environment of the codec
to only those resources that are needed by the codec. Those resources are
the media file that is handed out to the codec as a ROM module, a facility
to output video frames in the form of a framebuffer session, and a facility
to output an audio stream in the form of an audio-out session.

In order to reuse as much code as possible, the video player executes an
existing example application called avplay that comes with the codec library as child
component. The avplay example uses libSDL as backend for video and audio
output and responds to a few keyboard shortcuts for controlling the video
playback such as pausing the video. Because there exists a Genode version
of libSDL, avplay can be executed as a Genode component with no modifications.
This version of libSDL requests a framebuffer (Section [Framebuffer]) and
audio-out (Section [Audio-output]) session to perform the video and audio
output.
To handle user input, it opens an input session (Section [Input]).
Furthermore, it opens a ROM session for obtaining a configuration. This
configuration parametrizes the audio backend of libSDL.
Because avplay is a child of the video player application, all those session
requests are directed to the application. It is entirely up to the application
how to respond to those request. For accommodating the
request for a frambuffer session, the application creates a second nitpicker
session, configures a virtual framebuffer, and embeds this virtual framebuffer
into its GUI. It keeps the nitpicker session capability for itself and
merely hands out the virtual framebuffer's session capability to avplay.
For accommodating the request for the input session, it hands out a
capability to a locally-implemented input session. Using this input session,
it becomes able to supply artificial input events to avplay. For example,
when the user clicks on the play button of the application's GUI, the
application would submit a sequence of press and release events to the
input sessions, which appear to avplay as the keyboard shortcut for starting
the playback.
To let the user adjust the audio parameters of libSDL during runtime,
the video player application, dynamically changes the avplay configuration
using the mechanism described in
Section [Dynamic component reconfiguration at runtime]. As a response to a
configuration update, libSDL's audio backend picks up the changed
configuration parameters and ajusts the audio playback accordingly.

By sandboxing avplay as a child component of the video player, a bug in
the video or audio codec can no longer compromise the application. The
execution environment of avplay is tailored to the needs of the codec.
In particular, it does not allow the codec to access any files or the
network. In the worst case, if avplay becomes corrupted, the possible
damage is restricted to producing wrong video or audio frames but it
can neither access any of the user's data nor can it communicate to the
outside world.


Component-level and OS-level virtualization
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

| TODO
; Debugging
; Noux


Interposing services
~~~~~~~~~~~~~~~~~~~~


Ceding the parenthood
~~~~~~~~~~~~~~~~~~~~~

| TODO
; loader


Publishing and subscribing
~~~~~~~~~~~~~~~~~~~~~~~~~~

| TODO


Enslaving services
~~~~~~~~~~~~~~~~~~

| TODO


Untangling circular dependencies
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

| TODO


